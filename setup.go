package main

import (
	"context"
	"fmt"
	"net/url"
	"os"
	"strings"

	"github.com/mattn/go-mastodon"
	"github.com/urfave/cli/v2"
	"gopkg.in/yaml.v3"
)

const oauthScopes = "read:accounts write:media write:statuses"

func askStr(prompt string, options string, defaultValue string) string {
	for {
		optionsPrompt := ""
		if defaultValue != "" {
			optionsPrompt = fmt.Sprintf(" [%s]", options)
		}
		fmt.Printf("%s%s: ", prompt, optionsPrompt)

		var response string
		fmt.Scanf("%s", &response)

		response = strings.TrimSpace(response)

		if response == "" {
			if defaultValue != "" {
				return defaultValue
			}
		} else {
			return response
		}
	}
}

func askBool(prompt string, defaultValue bool) bool {
	options := "Y/n"
	defaultValueStr := "Y"

	if !defaultValue {
		options = "y/N"
		defaultValueStr = "N"
	}

	for {
		responseStr := strings.ToLower(askStr(prompt, options, defaultValueStr))

		switch responseStr {
		case "yes":
			return true
		case "y":
			return true
		case "ye":
			return true
		case "t":
			return true
		case "true":
			return true
		case "no":
			return false
		case "n":
			return false
		case "f":
			return false
		case "false":
			return false
		}
	}
}

func withRetry(msg string, f func() error) error {
	for {
		err := f()
		if err != nil {
			fmt.Printf("%s: %s\n", msg, err)
			if askBool("Retry?", true) {
				continue
			}
			return err
		}
		return err
	}
}

func SetupCommand() *cli.Command {
	return &cli.Command{
		Name:  "setup",
		Usage: "set up access to Telegram and Mastodon",
		Action: func(ctx *cli.Context) error {
			var c Config

			_ = LoadConfig(&c) // use config as defaults, if it exists

			err := withRetry(
				"Setting up Mastodon access",
				func() error { return setupMastodon(ctx.Context, &c.Mastodon) },
			)
			if err != nil {
				return err
			}

			err = setupTelegram(ctx.Context, &c.Telegram)
			if err != nil {
				return err
			}

			fmt.Println()
			fmt.Println("Generated the following config:")
			fmt.Println()

			yaml.NewEncoder(os.Stdout).Encode(c)

			fmt.Println()
			path := askStr("Where should I save this config?", "./tg2fedi.yml", "./tg2fedi.yml")
			_, err = os.Stat(path)
			if err == nil {
				if !askBool("File already exists. Overwrite?", false) {
					fmt.Println("Exiting.")
					return nil
				}
			}
			if os.IsNotExist(err) {
				err = nil
			}
			if err != nil {
				return fmt.Errorf("stat: %s: %w", path, err)
			}

			f, err := os.Create(path)
			if err != nil {
				return fmt.Errorf("open: %s: %w", path, err)
			}
			defer f.Close()

			fmt.Fprintln(f, "# generated by \"tg2fedi setup\"")
			err = yaml.NewEncoder(f).Encode(c)
			if err != nil {
				return fmt.Errorf("encoding yaml: %w", err)
			}

			return nil
		},
	}
}

func setupTelegram(ctx context.Context, c *TelegramConfig) error {
	skip := false
	if u, err := c.CheckAuth(); err == nil {
		skip = askBool(fmt.Sprintf("Already logged in to Telegram as %s. Skip configuring Telegram access?", u.UserName), true)
	}
	if !skip {
		return withRetry(
			"Telegram access failed",
			func() error {
				fmt.Println("Message https://t.me/BotFather to create a new bot.")
				c.ApiToken = askStr("Telegram API token", "", "")
				u, err := c.CheckAuth()
				if err != nil {
					return err
				}
				fmt.Printf("Logged in to Telegram as %s.", u.UserName)
				return nil
			},
		)
	}

	fmt.Println("Configure channel IDs to repost from by modifying the file.")
	return nil
}

func setupMastodon(ctx context.Context, c *MastodonConfig) error {
	skipAppRegistration := false
	if err := c.CheckAppAuth(ctx); err == nil {
		skipAppRegistration = askBool("Mastodon app client ID/secret already configured. Skip configuring these?", true)
	}

	if !skipAppRegistration {
		if askBool("Do you have an OAuth client ID and secret from your Mastodon instance?", false) {
			if err := setupApp(ctx, c); err != nil {
				return err
			}
		} else {
			if err := createApp(ctx, c); err != nil {
				return err
			}
		}
	}

	skipUser := false
	if u, err := c.CheckUserAuth(ctx); err == nil {
		skipUser = askBool(fmt.Sprintf("User %s (%s) already logged in. Skip?", u.DisplayName, u.Username), true)
	}
	if !skipUser {
		setupUser(ctx, c)
	}
	return nil
}

func setupApp(ctx context.Context, c *MastodonConfig) error {
	for {
		c.Server = askStr("Your Mastodon instance address (with schema)", c.Server, c.Server)
		c.ClientID = askStr("Client ID", c.ClientID, c.ClientID)
		c.ClientSecret = askStr("Client Secret", c.ClientSecret, c.ClientSecret)
		if err := c.CheckAppAuth(ctx); err != nil {
			fmt.Printf("invalid client id/secret: %s\n", err)
			if askBool("Retry?", true) {
				continue
			}
			return nil
		}
		return nil
	}
}

func createApp(ctx context.Context, c *MastodonConfig) error {
	var server, clientName string
	website := "https://github.com/irth/tg2fedi"

	for {
		server = askStr("Your Mastodon instance address (with schema)", c.Server, c.Server)
		_, err := url.Parse(server)
		if err != nil {
			return fmt.Errorf("invalid server url: %s: %w", server, err)
		}
		clientName = "tg2fedi"
		if hostname, err := os.Hostname(); err == nil {
			clientName = fmt.Sprintf("tg2fedi @ %s", hostname)
		}
		clientName = askStr("A name to identify your app (appears in \"Posted by\")", clientName, clientName)
		website = askStr("Website (linked from \"Posted by\")", website, website)

		fmt.Printf("\nYou're about to create an app with the following configuration:\n\n")
		fmt.Printf("          instance: %s\n", server)
		fmt.Printf("  application name: %s\n", clientName)
		fmt.Printf("            scopes: %s\n", oauthScopes)
		fmt.Printf("           website: %s\n\n", website)

		if !askBool("Continue?", true) {
			continue
		}

		app, err := mastodon.RegisterApp(ctx, &mastodon.AppConfig{
			Server:     server,
			ClientName: clientName,
			Scopes:     oauthScopes,
			Website:    website,
		})

		if err != nil {
			fmt.Printf("\nCouldn't create the app: %s\n", err)
			if askBool("Do you want to try again?", true) {
				continue
			} else {
				return fmt.Errorf("couldn't create the app: %w", err)
			}
		}

		c.Server = server
		c.ClientID = app.ClientID
		c.ClientSecret = app.ClientSecret

		fmt.Printf("\nApp created on %s:\n\n", c.Server)
		fmt.Printf("      Client ID: %s\n", c.ClientID)
		fmt.Printf("  Client secret: %s\n\n", c.ClientSecret)
		fmt.Println("Keep these secret. You will be given the option to save them to a config file later.")
		return nil
	}
}

func setupUser(ctx context.Context, c *MastodonConfig) error {
	serverURL, err := url.Parse(c.Server)
	if err != nil {
		return fmt.Errorf("invalid server url: %s: %w", c.Server, err)
	}

	serverURL.Path = "/oauth/authorize"
	q := serverURL.Query()
	q.Set("response_type", "code")
	q.Set("client_id", c.ClientID)
	q.Set("redirect_uri", "urn:ietf:wg:oauth:2.0:oob")
	q.Set("scope", oauthScopes)
	serverURL.RawQuery = q.Encode()

	fmt.Printf("\nNow, open the following URL and log in to the account that you want the app to post as:\n\n")
	fmt.Println(serverURL.String())
	fmt.Printf("\nAfterwards, paste the token. Keep it secret, as it allows to post as your account.\n")
	for {
		c.Token = askStr("Token", "", "")
		user, err := c.CheckUserAuth(ctx)
		if err != nil {
			fmt.Printf("Invalid token: %s\n", err)
			if askBool("Retry?", true) {
				continue
			}
			return fmt.Errorf("invalid token: %w", err)
		}

		fmt.Printf("Logged in as %s (%s)\n", user.DisplayName, user.Username)
		return nil
	}
}
